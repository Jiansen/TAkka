\contentsline {section}{\numberline {1}Project Description}{1}{section.1}
\contentsline {subsection}{\numberline {1.1}Background and Motivation}{1}{subsection.1.1}
\contentsline {subsection}{\numberline {1.2}Project Aim}{1}{subsection.1.2}
\contentsline {subsection}{\numberline {1.3}Project Objectives}{2}{subsection.1.3}
\contentsline {section}{\numberline {2}Literature Review}{3}{section.2}
\contentsline {subsection}{\numberline {2.1}The $\pi $-calculus}{3}{subsection.2.1}
\contentsline {subsubsection}{\numberline {2.1.1}Syntax and Notations}{3}{subsubsection.2.1.1}
\contentsline {subsubsection}{\numberline {2.1.2}Equivalence Relations}{5}{subsubsection.2.1.2}
\contentsline {subsection}{\numberline {2.2}The Join-Calculus and the JoCaml Programming Language}{6}{subsection.2.2}
\contentsline {subsubsection}{\numberline {2.2.1}The Local Reflexive Chemical Machine (RCHAM)}{8}{subsubsection.2.2.1}
\contentsline {subsubsection}{\numberline {2.2.2}Distributed Solutions}{8}{subsubsection.2.2.2}
\contentsline {subsubsection}{\numberline {2.2.3}The Failure Model}{9}{subsubsection.2.2.3}
\contentsline {subsubsection}{\numberline {2.2.4}The JoCaml Programming Language}{9}{subsubsection.2.2.4}
\contentsline {subsection}{\numberline {2.3}The Ambient Calculus and the Obliq Programming Language}{9}{subsection.2.3}
\contentsline {subsubsection}{\numberline {2.3.1}The Ambient Calculus}{9}{subsubsection.2.3.1}
\contentsline {subsubsection}{\numberline {2.3.2}The Obliq Programming Language}{12}{subsubsection.2.3.2}
\contentsline {subsection}{\numberline {2.4}The Erlang Language and The OTP Design principles }{12}{subsection.2.4}
\contentsline {subsubsection}{\numberline {2.4.1}Supervision Trees}{12}{subsubsection.2.4.1}
\contentsline {subsubsection}{\numberline {2.4.2}Behaviours}{13}{subsubsection.2.4.2}
\contentsline {subsubsection}{\numberline {2.4.3}Applications}{13}{subsubsection.2.4.3}
\contentsline {subsection}{\numberline {2.5}Encoding Functions in Process Calculi}{14}{subsection.2.5}
\contentsline {subsubsection}{\numberline {2.5.1}Indirect Encoding}{14}{subsubsection.2.5.1}
\contentsline {subsubsection}{\numberline {2.5.2}The Blue Calculus: Encoding Functions in a Direct Style}{14}{subsubsection.2.5.2}
\contentsline {subsection}{\numberline {2.6}Implementation Strategies}{15}{subsection.2.6}
\contentsline {subsubsection}{\numberline {2.6.1}A General Purpose Virtual Machine}{15}{subsubsection.2.6.1}
\contentsline {subsubsection}{\numberline {2.6.2}Extending the Basic VM}{16}{subsubsection.2.6.2}
\contentsline {subsubsection}{\numberline {2.6.3}Example Paradigms}{17}{subsubsection.2.6.3}
\contentsline {section}{\numberline {3}Some Research Problems}{18}{section.3}
\contentsline {subsection}{\numberline {3.1}Name Server that Combines Static and Dynamic Typing}{18}{subsection.3.1}
\contentsline {subsection}{\numberline {3.2}Hot Code Swapping}{18}{subsection.3.2}
\contentsline {subsection}{\numberline {3.3}Actor Parametrised on the Type of Expecting Messages}{18}{subsection.3.3}
\contentsline {subsection}{\numberline {3.4}Wadler's Type Pollution Problem}{19}{subsection.3.4}
\contentsline {subsection}{\numberline {3.5}Eventual Consistency for Shared States}{19}{subsection.3.5}
\contentsline {section}{\numberline {4}Project Progress and Plans}{20}{section.4}
\contentsline {subsection}{\numberline {4.1}Progress Achieved since the First Panel Review}{20}{subsection.4.1}
\contentsline {subsection}{\numberline {4.2}Plan for the Second Year}{20}{subsection.4.2}
\contentsline {subsection}{\numberline {4.3}Plan for the Third Year}{20}{subsection.4.3}
\contentsline {subsection}{\numberline {4.4}Potential Risks}{20}{subsection.4.4}
\contentsline {section}{\numberline {A}Scala Join (version 0.3) User Manual}{22}{appendix.A}
\contentsline {subsection}{\numberline {A.1}Using the Library}{22}{subsection.A.1}
\contentsline {subsubsection}{\numberline {A.1.1}Sending messages via channels}{22}{subsubsection.A.1.1}
\contentsline {subsubsection}{\numberline {A.1.2}Grouping join patterns}{22}{subsubsection.A.1.2}
\contentsline {subsubsection}{\numberline {A.1.3}Distributed computation}{23}{subsubsection.A.1.3}
\contentsline {subsection}{\numberline {A.2}Implementation Details}{25}{subsection.A.2}
\contentsline {subsubsection}{\numberline {A.2.1}Case Statement, Extractor Objects and Pattern Matching in Scala}{25}{subsubsection.A.2.1}
\contentsline {subsubsection}{\numberline {A.2.2}Implementing local channels}{26}{subsubsection.A.2.2}
\contentsline {subsubsection}{\numberline {A.2.3}Implementing the join pattern using extractor objects}{27}{subsubsection.A.2.3}
\contentsline {subsubsection}{\numberline {A.2.4}Implementing distributed join calculus}{31}{subsubsection.A.2.4}
\contentsline {subsection}{\numberline {A.3}Limitations and Future Improvements}{32}{subsection.A.3}
\contentsline {subsubsection}{\numberline {A.3.1}Assumption on linear pattern}{32}{subsubsection.A.3.1}
\contentsline {subsubsection}{\numberline {A.3.2}Limited number of patterns in a single join definition}{33}{subsubsection.A.3.2}
\contentsline {subsubsection}{\numberline {A.3.3}Unnatural usages of synchronous channels}{33}{subsubsection.A.3.3}
\contentsline {subsubsection}{\numberline {A.3.4}Straightforward implementation for synchronous channels}{33}{subsubsection.A.3.4}
\contentsline {subsubsection}{\numberline {A.3.5}Type of the join pattern and the unapply methods}{34}{subsubsection.A.3.5}
