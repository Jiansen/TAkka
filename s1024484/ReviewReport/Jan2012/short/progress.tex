\section{Reaserch Progress}

After submitting the first year report, I fixed some bugs in my Scala Join library and studied more materials on type theories and distributed programming.

Before the first panel review, I implemented a prototype Scala library that mimicking some features of OTP principles.  Most components of the library were implemented before the first panel review.  The library includes traits that models process and process reference.  Then, I used those two traits to implement a Supervisor trait and a GenServer trait, based on the Scala Actor library.  The GenServer trait is corresponding to the $gen\_server$ OTP module, which is a common choice for implementing a worker process in a supervision tree.  Another popular module to implement a worker process in OTP, $gen\_fsm$\footnote{an abstraction for finite state machine}, naturally maps to a join definition, which is captured by my Scala Join library.  The remaining challenge is providing a proper abstraction that models both actors and joins.

In the first two months after the first panel review, I spent some efforts to correct bugs in my Scala Join library.  The early versions\footnote{Scala Join(version 0.1) and Scala Join(version 0.2)} of the library do not consider the case of using values or nested patterns as message patterns.  In an unpublished version of Scala Joins library, Dr. Haller solved this problem by examining permutation of all messages.  After a few attempts, I improved the efficiency in my later implementation.  The current library implementation still has the problem of using locks when attempting to fire a pattern.  Locking the processes of examining patterns and firing matched patterns may cause deadlock when executing some complex join definitions.

During the work of improving the Scala Join library, I was reminded two problems of the Scala language.  Firstly, pattern matching in Scala are compiled to finite state machine.   Using nested patterns requires exponential number of intermediate states during compile time.   Without due care, using complex nested patterns in an implementation may result to stack overflow at compile time.  Secondly, tail recursion is not optimised by JVM.  For simple cases where a method calls itself as the last action, the Scala compiler converts the tail recursion to identical iteration.  Nevertheless, optimisation for tail recursion is not supported by Scala in general.

Continuing the work of implementing a prototype Scala library that supports OTP principles, I found a way of mimicking hot code swap via object delegation.  In my design, an improved GenServer maintains two references to server implementations, the $old$ one and the $current$ one.  By doing this, the GenServer could mimic Erlang style hot code swap to some extent.  However, the Genserver itself cannot be hot swapped.  This is different from the behaviour of Erlang platform, where any code could be hot swapped.

Before the new year, three medium-sized applications had been identified.  By the time of this writing, the two smaller examples, an ATM simulator and an elevator controller, have been ported into Scala using the akka library\cite{akka}.  The elevator controller example contains an additional interface for properties checking using QuickCheck.  I am working on porting QuickCheck properties specified in the Erlang version.  The work of porting the largest example, Riak core\cite{riak}, will be started soon.

From the work of porting the ATM simulator example and the elevator controller example, I identified some problems of implementing an akka and Scala compatible actor which have a type parameter that specifies the type of its expecting messages.  Details of those problems will be discussed in \S\ref{typed actor}.

In the last report, I mentioned Wadler's type pollution problem.  One solution is using sub-typing.  However, naively introducing new mediate types is awkward and does not cope with the dynamic configuration of most systems.  To improve the situation, I recently realised that union types could specify a type in a type hierarchy without introducing a new name.  The other solution, suggested by Professor Wadler, is using different channels.  In addition to join-calculus\cite{full_join} , we recently investigated the session types\cite{Honda93typesfor, Honda_languageprimitives}, where each channel is only used for the communication between two parties at a time.

Lastly, Professor Wadler and I agreed that eventually consistency policy \cite{Eventually_Consistent_Transactions, Vogels_2009} should be applied to shared states.  Works on  revision diagrams\cite{Eventually_Consistent_Transactions} appear to be especially promising.